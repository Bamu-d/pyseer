#!/usr/bin/env python

def get_options():
    import argparse

    description = 'SEER on continuous phenotypes, rewritten in python'
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('kmers',
                        help='Kmers file')
    parser.add_argument('phenotypes',
                        help='Phenotypes file')
    parser.add_argument('structure',
                        help='Population structure file')
    
    parser.add_argument('--min-maf',
                        type=float,
                        default=0.2,
                        help='Minimum MAF [Default: 0.2]')
    parser.add_argument('--max-maf',
                        type=float,
                        default=0.8,
                        help='Maximum MAF [Default: 0.8]')
    parser.add_argument('--filter-pvalue',
                        type=float,
                        default=1E-5,
                        help='Prefiltering t-test pvalue threshold [Default: 1E-5]')

    return parser.parse_args()

if __name__ == "__main__":
    options = get_options()

    import sys
    import numpy as np
    import pandas as pd
    from scipy import stats

    import statsmodels.formula.api as smf

    p = pd.DataFrame([float(x.rstrip().split()[-1])
                      for x in open(options.phenotypes)],
                     index=[x.split()[0]
                            for x in open(options.phenotypes)])

    m = pd.read_table(options.structure,
                      sep=',',
                      header=None)
    m.index = p.index

    k = {}
    for l in open(options.kmers):
        kmer, strains = l.split()[0], l.rstrip().split()[2:]
        k[kmer] = {x.split(':')[0]: int(x.split(':')[1])
                   for x in strains}
    k = pd.DataFrame(k).T
    k[np.isnan(k)] = 0.0
    ksum = k.T.sum() / k.shape[1]
    k = k.loc[ksum[(ksum >= options.min_maf) & (ksum <= options.max_maf)].index]

    fkmer = {kmer for kmer in k.index
             if stats.ttest_ind(p.loc[p.index[k.loc[kmer] >= 1]],
                                p.loc[p.index[k.loc[kmer] == 0]],
                                equal_var=False)[1] <= options.filter_pvalue}

    reimp = []
    for kmer in sorted(fkmer):
        v = np.concatenate((p.values.reshape(-1, 1),
                            k.loc[kmer].values.reshape(-1, 1),
                            m.values),
                           axis=1)
        df = pd.DataFrame(v,
                          columns=['expression', 'kmer', 'PC1', 'PC2', 'PC3'])
        mod1 = smf.ols(formula='expression ~ kmer + PC1 + PC2 + PC3', data=df)
        mod2 = smf.ols(formula='expression ~ PC1 + PC2 + PC3', data=df)
        res1 = mod1.fit()
        res2 = mod2.fit()
        reimp.append((kmer, ksum.loc[kmer], res1.compare_lr_test(res2)[1], res1.params.kmer))
    reimp = pd.DataFrame(reimp,
                         columns=['kmer', 'maf', 'lrt', 'beta']).set_index('kmer')
    reimp.to_csv(sys.stdout, sep='\t')
