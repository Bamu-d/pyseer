#!/usr/bin/env python

def get_options():
    import argparse

    description = 'SEER, rewritten in python'
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument('kmers',
                        help='Kmers file')
    parser.add_argument('phenotypes',
                        help='Phenotypes file')
    parser.add_argument('distances',
                        help='Strains distance square matrix')
    
    parser.add_argument('--min-maf',
                        type=float,
                        default=0.2,
                        help='Minimum MAF [Default: 0.2]')
    parser.add_argument('--max-maf',
                        type=float,
                        default=0.8,
                        help='Maximum MAF [Default: 0.8]')
    parser.add_argument('--filter-pvalue',
                        type=float,
                        default=1E-5,
                        help='Prefiltering t-test pvalue threshold [Default: 1E-5]')
    parser.add_argument('--max-dimensions',
                        type=int,
                        default=3,
                        help='Maximum number of dimensions to consider after MDS [Default: 3]')

    return parser.parse_args()


# thanks to Francis Song for this function
# source: http://www.nervouscomputer.com/hfs/cmdscale-in-python/
def cmdscale(D):
    """
    Classical multidimensional scaling (MDS)

    Parameters
    ----------
    D : (n, n) array
        Symmetric distance matrix.

    Returns
    -------
    Y : (n, p) array
        Configuration matrix. Each column represents a dimension. Only the
        p dimensions corresponding to positive eigenvalues of B are returned.
        Note that each dimension is only determined up to an overall sign,
        corresponding to a reflection.

    e : (n,) array
        Eigenvalues of B.
    """
    # Number of points
    n = len(D)

    # Centering matrix
    H = np.eye(n) - np.ones((n, n))/n

    # YY^T
    B = -H.dot(D**2).dot(H)/2

    # Diagonalize
    evals, evecs = np.linalg.eigh(B)

    # Sort by eigenvalue in descending order
    idx   = np.argsort(evals)[::-1]
    evals = evals[idx]
    evecs = evecs[:,idx]

    # Compute the coordinates using positive-eigenvalued components only
    w, = np.where(evals > 0)
    L  = np.diag(np.sqrt(evals[w]))
    V  = evecs[:,w]
    Y  = V.dot(L)

    return Y, evals


if __name__ == "__main__":
    options = get_options()

    import sys
    import numpy as np
    import pandas as pd
    from scipy import stats

    import statsmodels.formula.api as smf

    p = pd.DataFrame([float(x.rstrip().split()[-1])
                      for x in open(options.phenotypes)],
                     index=[x.split()[0]
                            for x in open(options.phenotypes)])

    m = pd.read_table(options.distances,
                      index_col=0)
    # restrict to strains for which we have phenotypes
    m = m.loc[p.index, p.index]
    m = pd.DataFrame(cmdscale(m)[0][:, :options.max_dimensions],
                     index=m.index)
    for i in range(m.shape[1]):
        m[i] = m[i] / max(abs(m[i]))

    k = {}
    for l in open(options.kmers):
        kmer, strains = l.split()[0], l.rstrip().split()[2:]
        k[kmer] = {x.split(':')[0]: int(x.split(':')[1])
                   for x in strains}
    k = pd.DataFrame(k).T
    k[np.isnan(k)] = 0.0
    # obtain and filter by maf
    ksum = k.T.sum() / k.shape[1]
    k = k.loc[ksum[(ksum >= options.min_maf) & (ksum <= options.max_maf)].index]

    # prefilter the kmers
    fkmer = {kmer for kmer in k.index
             if stats.ttest_ind(p.loc[p.index[k.loc[kmer] >= 1]],
                                p.loc[p.index[k.loc[kmer] == 0]],
                                equal_var=False)[1] <= options.filter_pvalue}

    reimp = []
    for kmer in sorted(fkmer):
        v = np.concatenate((p.values.reshape(-1, 1),
                            k.loc[kmer].values.reshape(-1, 1),
                            m.values),
                           axis=1)
        df = pd.DataFrame(v,
                          columns=['expression', 'kmer', 'PC1', 'PC2', 'PC3'])
        mod1 = smf.ols(formula='expression ~ kmer + PC1 + PC2 + PC3', data=df)
        mod2 = smf.ols(formula='expression ~ PC1 + PC2 + PC3', data=df)
        res1 = mod1.fit()
        res2 = mod2.fit()
        reimp.append((kmer, ksum.loc[kmer], res1.compare_lr_test(res2)[1], res1.params.kmer))
    reimp = pd.DataFrame(reimp,
                         columns=['kmer', 'maf', 'lrt', 'beta']).set_index('kmer')
    reimp.to_csv(sys.stdout, sep='\t')
